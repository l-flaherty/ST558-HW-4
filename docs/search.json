[
  {
    "objectID": "ST558 HW4 Quarto Doc.html",
    "href": "ST558 HW4 Quarto Doc.html",
    "title": "ST558 HW #4 Liam Flaherty",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\n\nThe function lapply is essentially the apply() function for lists. It takes in a list and applies a function to each list element. The equivalent purrr function is map.\n\n\n\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this.\n\n\nWe can run the code lapply(my_list, function(x) cor(x, method=\"kendall\")). The below code chunk checks that this works on some sample data.\n\n\nset.seed(558)\nmy_list=list(\n  df1=data.frame(runif(5), rnorm(5)),\n  df2=data.frame(rnorm(6), runif(6)))\n\na=lapply(my_list, function(x) cor(x, method=\"kendall\"))\n\na\n\n$df1\n         runif.5. rnorm.5.\nrunif.5.      1.0     -0.4\nrnorm.5.     -0.4      1.0\n\n$df2\n           rnorm.6.   runif.6.\nrnorm.6. 1.00000000 0.06666667\nrunif.6. 0.06666667 1.00000000\n\nall.equal(cor(my_list[[1]], method=\"kendall\"), a[[1]])\n\n[1] TRUE\n\nall.equal(cor(my_list[[2]], method=\"kendall\"), a[[2]])\n\n[1] TRUE\n\nrm(a, my_list)\n\n\n\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\n\nThe functions in the purrr packages are a bit slower than their counterparts in BaseR, but as a tradeoff, the formatting is more uniform and the syntax more clear. Additionally, helper functions like pluck() from the purrr library might make the overall code more efficient and readable.\n\n\n\n\n\nWhat is a side-effect function?\n\n\nA side-effect function is a function that doesn’t actually try to change the data, but just produces something. For example, print() and plot() are side-effect functions, in contrast to things like select() and mutate() from the tidyverse, which are transformation functions.\n\n\n\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nR creates a temporary function environment each time your function is called. Once the function is run, this environment is then removed, so any variables defined within the function will not be in the global environment and will be inaccessible. Of note is that R pursues it’s normal environment search even within the function. For example, if an object y is defined prior to writing a function, and then a new variable y is declared inside the function, the function will work with the second y, and the first y will still be accessible in the global environment after the function is called. However if y is used inside the function without a new y being specified, the function will use the y stored in memory when it is called.\n\n\n\n\n\n\n\nWe would like to create a user-defined function (udf) to get the Root Mean Square Error (RMSE) of two vectors. We name our function getRMSE() whose two inputs are vectors of the same length (there is nothing to predict if there isn’t actually a response). Note further that the order of the function inputs are irrelevant since the difference between the response and predicted values (i.e. the residuals) are being squared. We add in an unnamed argument with ... that allows users to pass along a function to the mean function used within getRMSE. This is particularly useful since R cannot calculate the mean of a vector with missing values, but can if users specify to remove the missing values first. For example, if v is a vector with missing values, mean(v) would return an NA while mean(v, na.rm=TRUE) would return the mean of the non-NA values.\n\ngetRMSE=function(response,predict, ...) {\n  sqrt(\n    mean( (response-predict)^2, ...))\n}\n\n\n\n\nWe now test our above getRMSE() function on some data. Notice that our response is a linear function of some covariate \\(x\\)– we would expect our response and predictor to be linked.\n\nset.seed(10)\nn=100\nx=runif(n)\nresp=3+10*x+rnorm(n)\npred=predict(lm(resp~x), data.frame(x))\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nWe can also test the function against data with missing values. To do so, we remove the first two elements of our resp vector and create a new vector of predictions based on this vector.\n\nmiss=NA_real_\nnumber=2\n\nmissing_resp=c(rep(miss, number), resp[(number+1):length(resp)])\nmissing_pred=predict(lm(missing_resp~x), data.frame(x))\n\nhead(missing_resp)\n\n[1]        NA        NA  8.637031 12.068788  4.357179  6.040709\n\n\nWe then pass these values into our getRMSE() function. When the user doesn’t specify na.rm=TRUE, they get an NA– R can’t calculate the mean of data with NAs.\n\ngetRMSE(missing_resp, missing_pred)\n\n[1] NA\n\n\nBut if the user does specify na.rm=TRUE in the RMSE() function, it works as expected.\n\ngetRMSE(missing_resp, missing_pred, na.rm=TRUE)\n\n[1] 0.9661358\n\n\n\n\n\nWhat if instead we wanted to explore the Mean Absolute Error (MAE)? We could create a similar function to our getRMSE(). The same notes we had about RMSE apply here– order of function inputs doesn’t matter, and inputs must be vectors of the same length.\n\ngetMAE=function(response, predict,...) {\n  mean( abs(response-predict), ...)\n}\n\n\n\n\nWe check our getMAE function against the same data we had tested earlier.\n\nset.seed(10)\nn=100\nx=runif(n)\nresp=3+10*x+rnorm(n)\npred=predict(lm(resp~x), data.frame(x))\n\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nJust like before, we want to see that the function works with missing values. We again replace a couple values with NAs and rerun our regression.\n\nmiss=NA_real_\nnumber=2\n\nmissing_resp=c(rep(miss, number), resp[(number+1):length(resp)])\nmissing_pred=predict(lm(missing_resp~x), data.frame(x))\nhead(missing_resp)\n\n[1]        NA        NA  8.637031 12.068788  4.357179  6.040709\n\n\nAgain we see that when users fail to pass on a na.rm=TRUE, the function errors, but otherwise works as expected.\n\ngetMAE(missing_resp, missing_pred)\n\n[1] NA\n\ngetMAE(missing_resp, missing_pred, na.rm=TRUE)\n\n[1] 0.8233219\n\n\n\n\n\nWe would like a user to be able to easily specify which of these measures they’d like to see. We wrap our previous function in a single function function_predict_eval() which takes as inputs two equal length numeric vectors along with a user specified string indicating which measure they’d like to return. Our function_predict_eval() returns both the RMSE and MAE by default, but the user can specify the string \"MAE\" after inputting their response and prediction vectors if they’d only like to see that measurement (the same applies for inputting the string \"RMSE\"). Just like in our getRMSE() and getMAE() functions, we add unnamed functions with ... (mainly so the user has the option to specify na.rm=TRUE if they know their vectors have missing data). Note that before any calculations are performed, we first test that the inputs to the function are as desired. If they aren’t, we immediately exit the function by return()ing an error message to the user.\n\nfunction_predict_eval=function(response, predict, default_measure=\"both\",...) {\n  \n  if(is.vector(predict)+is.vector(response)+\n     is.numeric(predict)+is.numeric(response)+\n     is.atomic(predict)+is.atomic(response)!= 6) {\n    return(\"ERROR, CHECK INPUTS\")\n  } else {\n     df=data.frame(\n      RMSE=getRMSE(response, predict,...), \n      MAE=getMAE(response, predict,...))\n  }\n  \n  if(default_measure==\"RMSE\") {\n    df[,\"RMSE\"]\n  } else if (default_measure==\"MAE\") {\n    df[,\"MAE\"]\n  } else if (default_measure==\"both\") {\n    df\n  } else {\n    \"ERROR, CHECK INPUTS\"\n  }\n}\n\n\n\n\nWe want to test our wrapper function against the same data we’ve looked at before. Our responses and predicted values are given by the below.\n\nset.seed(10)\nn=100\nx=runif(n)\nresp=3+10*x+rnorm(n)\npred=predict(lm(resp~x), data.frame(x))\nhead(resp)\n\n[1]  7.674144  5.733128  8.637031 12.068788  4.357179  6.040709\n\n\nIn turn, we use this data and our function_predict_eval() function to return the RMSE, the MAE, and both metrics.\n\nfunction_predict_eval(resp, pred, \"RMSE\")\n\n[1] 0.9581677\n\nfunction_predict_eval(resp, pred, \"MAE\")\n\n[1] 0.8155776\n\nfunction_predict_eval(resp, pred)\n\n       RMSE       MAE\n1 0.9581677 0.8155776\n\n\nAll three of these function calls match our previous values. We also want to make sure wrapper function works with missing data. We replace two prediction values with NA’s like we did previously.\n\nmiss=NA_real_\nnumber=2\n\nmissing_resp=c(rep(miss, number), resp[(number+1):length(resp)])\nmissing_pred=predict(lm(missing_resp~x), data.frame(x))\nhead(missing_resp)\n\n[1]        NA        NA  8.637031 12.068788  4.357179  6.040709\n\n\nIn each case, specifying our unnamed argument to be na.rm=TRUE handles our data, while leaving it unspecified returns NA, as desired.\n\nfunction_predict_eval(missing_resp, missing_pred, \"RMSE\")\n\n[1] NA\n\nfunction_predict_eval(missing_resp, missing_pred, \"RMSE\", na.rm=TRUE)\n\n[1] 0.9661358\n\nfunction_predict_eval(missing_resp, missing_pred, \"MAE\")\n\n[1] NA\n\nfunction_predict_eval(missing_resp, missing_pred, \"MAE\", na.rm=TRUE)\n\n[1] 0.8233219\n\nfunction_predict_eval(missing_resp, missing_pred)\n\n  RMSE MAE\n1   NA  NA\n\nfunction_predict_eval(missing_resp, missing_pred,na.rm=TRUE)\n\n       RMSE       MAE\n1 0.9661358 0.8233219\n\n\nWe’d finally like to check that the our function_predict_eval() function can handle input errors. We pass it in a singe data frame instead of two vectors, and see that it does.\n\ndf=data.frame(resp, pred)\nfunction_predict_eval(df, \"RMSE\")\n\n[1] \"ERROR, CHECK INPUTS\"\n\n\n\n\n\n\nFor all the below questions, we query the Application Programming Interface (API) available at https://newsapi.org. Since we’re dealing with API’s, we load in the httr package.\n\n\nThe documentation provided in https://newsapi.org/docs gives information on how to build our url. We want to research articles on baseball over the last few days, so fill out our url accordingly. Note that the API key we provided came from a free trial with the site.\n\nlibrary(httr)\n\ntopic=\"baseball\"\nkey=\"78a2743e6eb946c99d808fc82ec2fed6\"\nstart_date=\"2024-06-20\"\nend_date=\"2024-06-21\"\nsort=\"popularity\"\n\nmy_url=paste0(\"https://newsapi.org/v2/everything?\", \n           \"q=\", topic, \n           \"&from=\", start_date,\n           \"&to=\", end_date,\n           \"&sortBy=\", sort,\n           \"&apiKey=\", key)\n\napi_return=GET(my_url)          #GET is from httr package#\n\nstr(api_return, max.level=1)    #glimpse of what the API returns#\n\nList of 10\n $ url        : chr \"https://newsapi.org/v2/everything?q=baseball&from=2024-06-20&to=2024-06-21&sortBy=popularity&apiKey=78a2743e6eb\"| __truncated__\n $ status_code: int 200\n $ headers    :List of 16\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    0 obs. of  7 variables:\n $ content    : raw [1:80781] 7b 22 73 74 ...\n $ date       : POSIXct[1:1], format: \"2024-06-23 02:49:26\"\n $ times      : Named num [1:6] 0 0.00724 0.0448 0.07242 0.19289 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\n\n\n\nWe can use the jsonlite package to convert the JavaScript Object Notation (JSON) data returned by the API into something more easily readable. Upon inspecting the element of our new object plaintext, we see that we got 508 articles, which we can access through the third list item, a data frame called articles.\n\nlibrary(jsonlite)\n\nplaintext=fromJSON(rawToChar(api_return$content))\n\nstr(plaintext, max.level=1)\n\nList of 3\n $ status      : chr \"ok\"\n $ totalResults: int 512\n $ articles    :'data.frame':   100 obs. of  8 variables:\n\n\nSummarizing our data frame, we see a few different variables\n\nnews_articles=plaintext$articles\nsummary(news_articles)\n\n     source.id          source.name        author             title          \n Length:100          Length:100         Length:100         Length:100        \n Class :character    Class :character   Class :character   Class :character  \n Mode  :character    Mode  :character   Mode  :character   Mode  :character  \n description            url             urlToImage        publishedAt       \n Length:100         Length:100         Length:100         Length:100        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n   content         \n Length:100        \n Class :character  \n Mode  :character  \n\n\nWe can pick out a few items of interest using normal baseR operations, and then use an anonymous function within apply() to make our output manageable.\n\nreduced=as.data.frame(apply(\n  news_articles[,c(\"url\", \"author\", \"title\")], \n  2, \n  function(x) substr(x,1,30)))\n\nhead(reduced)\n\n                             url                         author\n1 https://www.npr.org/2024/06/21                Steve Futterman\n2 https://www.businessinsider.co                Mykenna Maniece\n3 https://www.businessinsider.co                  Isobella Jade\n4 https://venturebeat.com/ai/don                       VB Staff\n5 https://ktla.com/news/local-ne                    Josh DuBose\n6 https://www.espn.com/fantasy/b Tristan H. Cockcroft and Eric \n                           title\n1 MLB game in Alabama takes on e\n2 Photos show Team USA's 2024 Ol\n3 Summer as a divorced parent go\n4 Don’t miss OpenAI digging into\n5 Family in Southern California \n6 Weekend preview: NL East teams\n\n\nWe can even read the contents of the articles with the content column in our original news_articles data frame!\n\nnews_articles$content[1]         #Say Hey! RIP to an all-timer. Only Babe is higher on my GOAT list#\n\n[1] \"Major League Baseball played at historic Rickwood Field in Birmingham, Ala., Thursday. It is where Willie Mays, who died this week at age 93, made his professional debut in the Negro Leagues.\"\n\n\n\n\n\nWe would not like to write a function that allows us to easily query this API. Putting our previous steps together, we have the below.\n\nfunction_api_query=function(subject, time, key) {\n  \n  my_url=paste0(\"https://newsapi.org/v2/everything?\", \n           \"q=\", subject, \n           \"&from=\", time,\n           \"&apiKey=\", key)\n  \n  api_return=GET(my_url)\n  plaintext=fromJSON(rawToChar(api_return$content))\n  a=plaintext$articles\n  b=a[,c(\"url\", \"author\", \"title\", \"content\")]\n  \n  \n  return(b)\n}\n\nWe can run this function on two topics of interest, say baseball and the Olympic trials.\n\ntopic1=\"baseball\"\ntopic2=\"1500m\"\n\ndate1=\"2024-06-20\"\ndate2=\"2024-06-18\"\n\nkey=\"78a2743e6eb946c99d808fc82ec2fed6\"\n\nbaseball_articles=function_api_query(topic1, date1, key)\nolympic_articles=function_api_query(topic2, date2, key)\n\nhead(baseball_articles[,c(\"author\", \"title\")])\n\n                                  author\n1                        Steve Futterman\n2 Tristan H. Cockcroft and Eric Karabell\n3                            Adam Gopnik\n4                            John Gruber\n5                            Josh DuBose\n6                               VB Staff\n                                                                                            title\n1                    MLB game in Alabama takes on extra significance following Willie Mays' death\n2                                                Weekend preview: NL East teams take center stage\n3                                                                          What Willie Mays Meant\n4          Reggie Jackson on Willie Mays’s Legacy, and Being a Black Baseball Player in the 1960s\n5                          Family in Southern California shaken after burglary crew ransacks home\n6 Don’t miss OpenAI digging into the nitty gritty of business transformation at VB Transform 2024\n\nhead(olympic_articles[,c(\"author\", \"title\")])\n\n          author\n1      BBC Sport\n2  Andrew Peters\n3  Scott Polacek\n4           &lt;NA&gt;\n5    James Dator\n6 James Brizuela\n                                                                                  title\n1                                   GB's Lewis wins second European Championships medal\n2 Katie Ledecky Qualifies for 2nd 2024 Olympics Event, Wins 200m Freestyle at US Trials\n3           Katie Ledecky Reveals Plan to Compete in 4 Swimming Events at 2024 Olympics\n4                                                                             [Removed]\n5           Katie Ledecky won the 1500m by so much that nobody else was in the TV frame\n6      Olympics News: Katie Ledecky Sets Another Record in Ridiculous 1500m Performance"
  },
  {
    "objectID": "ST558 HW4 Quarto Doc.html#task-1-conceptual-questions",
    "href": "ST558 HW4 Quarto Doc.html#task-1-conceptual-questions",
    "title": "ST558 HW #4 Liam Flaherty",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\n\nThe function lapply is essentially the apply() function for lists. It takes in a list and applies a function to each list element. The equivalent purrr function is map.\n\n\n\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this.\n\n\nWe can run the code lapply(my_list, function(x) cor(x, method=\"kendall\")). The below code chunk checks that this works on some sample data.\n\n\nset.seed(558)\nmy_list=list(\n  df1=data.frame(runif(5), rnorm(5)),\n  df2=data.frame(rnorm(6), runif(6)))\n\na=lapply(my_list, function(x) cor(x, method=\"kendall\"))\n\na\n\n$df1\n         runif.5. rnorm.5.\nrunif.5.      1.0     -0.4\nrnorm.5.     -0.4      1.0\n\n$df2\n           rnorm.6.   runif.6.\nrnorm.6. 1.00000000 0.06666667\nrunif.6. 0.06666667 1.00000000\n\nall.equal(cor(my_list[[1]], method=\"kendall\"), a[[1]])\n\n[1] TRUE\n\nall.equal(cor(my_list[[2]], method=\"kendall\"), a[[2]])\n\n[1] TRUE\n\nrm(a, my_list)\n\n\n\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\n\nThe functions in the purrr packages are a bit slower than their counterparts in BaseR, but as a tradeoff, the formatting is more uniform and the syntax more clear. Additionally, helper functions like pluck() from the purrr library might make the overall code more efficient and readable.\n\n\n\n\n\nWhat is a side-effect function?\n\n\nA side-effect function is a function that doesn’t actually try to change the data, but just produces something. For example, print() and plot() are side-effect functions, in contrast to things like select() and mutate() from the tidyverse, which are transformation functions.\n\n\n\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nR creates a temporary function environment each time your function is called. Once the function is run, this environment is then removed, so any variables defined within the function will not be in the global environment and will be inaccessible. Of note is that R pursues it’s normal environment search even within the function. For example, if an object y is defined prior to writing a function, and then a new variable y is declared inside the function, the function will work with the second y, and the first y will still be accessible in the global environment after the function is called. However if y is used inside the function without a new y being specified, the function will use the y stored in memory when it is called."
  },
  {
    "objectID": "ST558 HW4 Quarto Doc.html#task-2-writing-r-functions",
    "href": "ST558 HW4 Quarto Doc.html#task-2-writing-r-functions",
    "title": "ST558 HW #4 Liam Flaherty",
    "section": "",
    "text": "We would like to create a user-defined function (udf) to get the Root Mean Square Error (RMSE) of two vectors. We name our function getRMSE() whose two inputs are vectors of the same length (there is nothing to predict if there isn’t actually a response). Note further that the order of the function inputs are irrelevant since the difference between the response and predicted values (i.e. the residuals) are being squared. We add in an unnamed argument with ... that allows users to pass along a function to the mean function used within getRMSE. This is particularly useful since R cannot calculate the mean of a vector with missing values, but can if users specify to remove the missing values first. For example, if v is a vector with missing values, mean(v) would return an NA while mean(v, na.rm=TRUE) would return the mean of the non-NA values.\n\ngetRMSE=function(response,predict, ...) {\n  sqrt(\n    mean( (response-predict)^2, ...))\n}\n\n\n\n\nWe now test our above getRMSE() function on some data. Notice that our response is a linear function of some covariate \\(x\\)– we would expect our response and predictor to be linked.\n\nset.seed(10)\nn=100\nx=runif(n)\nresp=3+10*x+rnorm(n)\npred=predict(lm(resp~x), data.frame(x))\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nWe can also test the function against data with missing values. To do so, we remove the first two elements of our resp vector and create a new vector of predictions based on this vector.\n\nmiss=NA_real_\nnumber=2\n\nmissing_resp=c(rep(miss, number), resp[(number+1):length(resp)])\nmissing_pred=predict(lm(missing_resp~x), data.frame(x))\n\nhead(missing_resp)\n\n[1]        NA        NA  8.637031 12.068788  4.357179  6.040709\n\n\nWe then pass these values into our getRMSE() function. When the user doesn’t specify na.rm=TRUE, they get an NA– R can’t calculate the mean of data with NAs.\n\ngetRMSE(missing_resp, missing_pred)\n\n[1] NA\n\n\nBut if the user does specify na.rm=TRUE in the RMSE() function, it works as expected.\n\ngetRMSE(missing_resp, missing_pred, na.rm=TRUE)\n\n[1] 0.9661358\n\n\n\n\n\nWhat if instead we wanted to explore the Mean Absolute Error (MAE)? We could create a similar function to our getRMSE(). The same notes we had about RMSE apply here– order of function inputs doesn’t matter, and inputs must be vectors of the same length.\n\ngetMAE=function(response, predict,...) {\n  mean( abs(response-predict), ...)\n}\n\n\n\n\nWe check our getMAE function against the same data we had tested earlier.\n\nset.seed(10)\nn=100\nx=runif(n)\nresp=3+10*x+rnorm(n)\npred=predict(lm(resp~x), data.frame(x))\n\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nJust like before, we want to see that the function works with missing values. We again replace a couple values with NAs and rerun our regression.\n\nmiss=NA_real_\nnumber=2\n\nmissing_resp=c(rep(miss, number), resp[(number+1):length(resp)])\nmissing_pred=predict(lm(missing_resp~x), data.frame(x))\nhead(missing_resp)\n\n[1]        NA        NA  8.637031 12.068788  4.357179  6.040709\n\n\nAgain we see that when users fail to pass on a na.rm=TRUE, the function errors, but otherwise works as expected.\n\ngetMAE(missing_resp, missing_pred)\n\n[1] NA\n\ngetMAE(missing_resp, missing_pred, na.rm=TRUE)\n\n[1] 0.8233219\n\n\n\n\n\nWe would like a user to be able to easily specify which of these measures they’d like to see. We wrap our previous function in a single function function_predict_eval() which takes as inputs two equal length numeric vectors along with a user specified string indicating which measure they’d like to return. Our function_predict_eval() returns both the RMSE and MAE by default, but the user can specify the string \"MAE\" after inputting their response and prediction vectors if they’d only like to see that measurement (the same applies for inputting the string \"RMSE\"). Just like in our getRMSE() and getMAE() functions, we add unnamed functions with ... (mainly so the user has the option to specify na.rm=TRUE if they know their vectors have missing data). Note that before any calculations are performed, we first test that the inputs to the function are as desired. If they aren’t, we immediately exit the function by return()ing an error message to the user.\n\nfunction_predict_eval=function(response, predict, default_measure=\"both\",...) {\n  \n  if(is.vector(predict)+is.vector(response)+\n     is.numeric(predict)+is.numeric(response)+\n     is.atomic(predict)+is.atomic(response)!= 6) {\n    return(\"ERROR, CHECK INPUTS\")\n  } else {\n     df=data.frame(\n      RMSE=getRMSE(response, predict,...), \n      MAE=getMAE(response, predict,...))\n  }\n  \n  if(default_measure==\"RMSE\") {\n    df[,\"RMSE\"]\n  } else if (default_measure==\"MAE\") {\n    df[,\"MAE\"]\n  } else if (default_measure==\"both\") {\n    df\n  } else {\n    \"ERROR, CHECK INPUTS\"\n  }\n}\n\n\n\n\nWe want to test our wrapper function against the same data we’ve looked at before. Our responses and predicted values are given by the below.\n\nset.seed(10)\nn=100\nx=runif(n)\nresp=3+10*x+rnorm(n)\npred=predict(lm(resp~x), data.frame(x))\nhead(resp)\n\n[1]  7.674144  5.733128  8.637031 12.068788  4.357179  6.040709\n\n\nIn turn, we use this data and our function_predict_eval() function to return the RMSE, the MAE, and both metrics.\n\nfunction_predict_eval(resp, pred, \"RMSE\")\n\n[1] 0.9581677\n\nfunction_predict_eval(resp, pred, \"MAE\")\n\n[1] 0.8155776\n\nfunction_predict_eval(resp, pred)\n\n       RMSE       MAE\n1 0.9581677 0.8155776\n\n\nAll three of these function calls match our previous values. We also want to make sure wrapper function works with missing data. We replace two prediction values with NA’s like we did previously.\n\nmiss=NA_real_\nnumber=2\n\nmissing_resp=c(rep(miss, number), resp[(number+1):length(resp)])\nmissing_pred=predict(lm(missing_resp~x), data.frame(x))\nhead(missing_resp)\n\n[1]        NA        NA  8.637031 12.068788  4.357179  6.040709\n\n\nIn each case, specifying our unnamed argument to be na.rm=TRUE handles our data, while leaving it unspecified returns NA, as desired.\n\nfunction_predict_eval(missing_resp, missing_pred, \"RMSE\")\n\n[1] NA\n\nfunction_predict_eval(missing_resp, missing_pred, \"RMSE\", na.rm=TRUE)\n\n[1] 0.9661358\n\nfunction_predict_eval(missing_resp, missing_pred, \"MAE\")\n\n[1] NA\n\nfunction_predict_eval(missing_resp, missing_pred, \"MAE\", na.rm=TRUE)\n\n[1] 0.8233219\n\nfunction_predict_eval(missing_resp, missing_pred)\n\n  RMSE MAE\n1   NA  NA\n\nfunction_predict_eval(missing_resp, missing_pred,na.rm=TRUE)\n\n       RMSE       MAE\n1 0.9661358 0.8233219\n\n\nWe’d finally like to check that the our function_predict_eval() function can handle input errors. We pass it in a singe data frame instead of two vectors, and see that it does.\n\ndf=data.frame(resp, pred)\nfunction_predict_eval(df, \"RMSE\")\n\n[1] \"ERROR, CHECK INPUTS\""
  },
  {
    "objectID": "ST558 HW4 Quarto Doc.html#task-3-querying-an-api-and-a-tidy-style-function",
    "href": "ST558 HW4 Quarto Doc.html#task-3-querying-an-api-and-a-tidy-style-function",
    "title": "ST558 HW #4 Liam Flaherty",
    "section": "",
    "text": "For all the below questions, we query the Application Programming Interface (API) available at https://newsapi.org. Since we’re dealing with API’s, we load in the httr package.\n\n\nThe documentation provided in https://newsapi.org/docs gives information on how to build our url. We want to research articles on baseball over the last few days, so fill out our url accordingly. Note that the API key we provided came from a free trial with the site.\n\nlibrary(httr)\n\ntopic=\"baseball\"\nkey=\"78a2743e6eb946c99d808fc82ec2fed6\"\nstart_date=\"2024-06-20\"\nend_date=\"2024-06-21\"\nsort=\"popularity\"\n\nmy_url=paste0(\"https://newsapi.org/v2/everything?\", \n           \"q=\", topic, \n           \"&from=\", start_date,\n           \"&to=\", end_date,\n           \"&sortBy=\", sort,\n           \"&apiKey=\", key)\n\napi_return=GET(my_url)          #GET is from httr package#\n\nstr(api_return, max.level=1)    #glimpse of what the API returns#\n\nList of 10\n $ url        : chr \"https://newsapi.org/v2/everything?q=baseball&from=2024-06-20&to=2024-06-21&sortBy=popularity&apiKey=78a2743e6eb\"| __truncated__\n $ status_code: int 200\n $ headers    :List of 16\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    0 obs. of  7 variables:\n $ content    : raw [1:80781] 7b 22 73 74 ...\n $ date       : POSIXct[1:1], format: \"2024-06-23 02:49:26\"\n $ times      : Named num [1:6] 0 0.00724 0.0448 0.07242 0.19289 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\n\n\n\nWe can use the jsonlite package to convert the JavaScript Object Notation (JSON) data returned by the API into something more easily readable. Upon inspecting the element of our new object plaintext, we see that we got 508 articles, which we can access through the third list item, a data frame called articles.\n\nlibrary(jsonlite)\n\nplaintext=fromJSON(rawToChar(api_return$content))\n\nstr(plaintext, max.level=1)\n\nList of 3\n $ status      : chr \"ok\"\n $ totalResults: int 512\n $ articles    :'data.frame':   100 obs. of  8 variables:\n\n\nSummarizing our data frame, we see a few different variables\n\nnews_articles=plaintext$articles\nsummary(news_articles)\n\n     source.id          source.name        author             title          \n Length:100          Length:100         Length:100         Length:100        \n Class :character    Class :character   Class :character   Class :character  \n Mode  :character    Mode  :character   Mode  :character   Mode  :character  \n description            url             urlToImage        publishedAt       \n Length:100         Length:100         Length:100         Length:100        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n   content         \n Length:100        \n Class :character  \n Mode  :character  \n\n\nWe can pick out a few items of interest using normal baseR operations, and then use an anonymous function within apply() to make our output manageable.\n\nreduced=as.data.frame(apply(\n  news_articles[,c(\"url\", \"author\", \"title\")], \n  2, \n  function(x) substr(x,1,30)))\n\nhead(reduced)\n\n                             url                         author\n1 https://www.npr.org/2024/06/21                Steve Futterman\n2 https://www.businessinsider.co                Mykenna Maniece\n3 https://www.businessinsider.co                  Isobella Jade\n4 https://venturebeat.com/ai/don                       VB Staff\n5 https://ktla.com/news/local-ne                    Josh DuBose\n6 https://www.espn.com/fantasy/b Tristan H. Cockcroft and Eric \n                           title\n1 MLB game in Alabama takes on e\n2 Photos show Team USA's 2024 Ol\n3 Summer as a divorced parent go\n4 Don’t miss OpenAI digging into\n5 Family in Southern California \n6 Weekend preview: NL East teams\n\n\nWe can even read the contents of the articles with the content column in our original news_articles data frame!\n\nnews_articles$content[1]         #Say Hey! RIP to an all-timer. Only Babe is higher on my GOAT list#\n\n[1] \"Major League Baseball played at historic Rickwood Field in Birmingham, Ala., Thursday. It is where Willie Mays, who died this week at age 93, made his professional debut in the Negro Leagues.\"\n\n\n\n\n\nWe would not like to write a function that allows us to easily query this API. Putting our previous steps together, we have the below.\n\nfunction_api_query=function(subject, time, key) {\n  \n  my_url=paste0(\"https://newsapi.org/v2/everything?\", \n           \"q=\", subject, \n           \"&from=\", time,\n           \"&apiKey=\", key)\n  \n  api_return=GET(my_url)\n  plaintext=fromJSON(rawToChar(api_return$content))\n  a=plaintext$articles\n  b=a[,c(\"url\", \"author\", \"title\", \"content\")]\n  \n  \n  return(b)\n}\n\nWe can run this function on two topics of interest, say baseball and the Olympic trials.\n\ntopic1=\"baseball\"\ntopic2=\"1500m\"\n\ndate1=\"2024-06-20\"\ndate2=\"2024-06-18\"\n\nkey=\"78a2743e6eb946c99d808fc82ec2fed6\"\n\nbaseball_articles=function_api_query(topic1, date1, key)\nolympic_articles=function_api_query(topic2, date2, key)\n\nhead(baseball_articles[,c(\"author\", \"title\")])\n\n                                  author\n1                        Steve Futterman\n2 Tristan H. Cockcroft and Eric Karabell\n3                            Adam Gopnik\n4                            John Gruber\n5                            Josh DuBose\n6                               VB Staff\n                                                                                            title\n1                    MLB game in Alabama takes on extra significance following Willie Mays' death\n2                                                Weekend preview: NL East teams take center stage\n3                                                                          What Willie Mays Meant\n4          Reggie Jackson on Willie Mays’s Legacy, and Being a Black Baseball Player in the 1960s\n5                          Family in Southern California shaken after burglary crew ransacks home\n6 Don’t miss OpenAI digging into the nitty gritty of business transformation at VB Transform 2024\n\nhead(olympic_articles[,c(\"author\", \"title\")])\n\n          author\n1      BBC Sport\n2  Andrew Peters\n3  Scott Polacek\n4           &lt;NA&gt;\n5    James Dator\n6 James Brizuela\n                                                                                  title\n1                                   GB's Lewis wins second European Championships medal\n2 Katie Ledecky Qualifies for 2nd 2024 Olympics Event, Wins 200m Freestyle at US Trials\n3           Katie Ledecky Reveals Plan to Compete in 4 Swimming Events at 2024 Olympics\n4                                                                             [Removed]\n5           Katie Ledecky won the 1500m by so much that nobody else was in the TV frame\n6      Olympics News: Katie Ledecky Sets Another Record in Ridiculous 1500m Performance"
  }
]